#include <iostream>
#include <string>
#include <stack>
using namespace std;
enum class Color {
	RED,
	BLACK
};
class App {
public:
	int id;
	string name;
	int size;
	int price;

	App(int id, string name, int size, int price) {
		this->id = id;
		this->name = name;
		this->size = size;
		this->price = price;
	}
};
class Node {
public:
	App* app;
	Node* leftNode;
	Node* rightNode;
	Node* parentNode;
	Color color;

	Node() {
		this->app = NULL;
		this->leftNode = NULL;
		this->rightNode = NULL;
		this->color = Color::BLACK;
	}

	Node(App* newApp) {
		app = newApp;
		this->leftNode = new Node();
		this->rightNode = new Node();
		this->color = Color::RED;
	}
};
class RedblackTree {
private:
	Node* root;
	
	void GRR(Node* grandParent, Node* parent, Node* child) {
		Node* saveLeft = parent->leftNode;
		// parent가 변경하는 subtree의 root.
		parent->leftNode = grandParent;
		parent->parentNode = grandParent->parentNode;
		// 기존 tree와 변경하는 subtreed와 연결.
		if (grandParent->parentNode != NULL) {
			if (grandParent->parentNode->leftNode == grandParent) grandParent->parentNode->leftNode = parent;
			else grandParent->parentNode->rightNode = parent;
		}
		// grandparent의 자식 설정.
		saveLeft->parentNode = grandParent;
		grandParent->rightNode = saveLeft;
		grandParent->parentNode = parent;
		// 변경한 subtree 노드들의 색을 알맞게 변경.
		setSubtreeNodeColor(parent);
		// 변경한 subtree가 root일 때 root로 설정.
		if (isRoot(parent)) setRoot(parent);
	}

	void GRL(Node* grandParent, Node* parent, Node* child) {
		Node* saveLeft = child->leftNode;
		Node* saveRight = child->rightNode;
		// 기존 tree와 변경하는 subtreed와 연결.
		if (grandParent->parentNode != NULL) {
			if (grandParent->parentNode->leftNode == grandParent) grandParent->parentNode->leftNode = child;
			else grandParent->parentNode->rightNode = child;
		}
		// child가 변경하는 subtree의 root.
		child->leftNode = grandParent;
		child->rightNode = parent;
		child->parentNode = grandParent->parentNode;
		// grandparent의 자식 설정.
		saveLeft->parentNode = grandParent;
 		grandParent->rightNode = saveLeft;
		grandParent->parentNode = child;
		// parent의 자식 설정.
		saveRight->parentNode = parent;
		parent->leftNode = saveRight;
		parent->parentNode = child;
		// 변경한 subtree 노드들의 색을 알맞게 변경.
		setSubtreeNodeColor(child);
		// 변경한 subtree가 root일 때 root로 설정.
		if (isRoot(child)) setRoot(child);
	}

	void GLL(Node* grandParent, Node* parent, Node* child) {
		Node* saveRight = parent->rightNode;
		// parent가 변경하는 subtree의 root.
		parent->rightNode = grandParent;
		parent->parentNode = grandParent->parentNode;
		// 기존 tree와 변경하는 subtreed와 연결.
		if (grandParent->parentNode != NULL) {
			if (grandParent->parentNode->leftNode == grandParent) grandParent->parentNode->leftNode = parent;
			else grandParent->parentNode->rightNode = parent;
		}
		// grandparent의 자식 설정.
		saveRight->parentNode = grandParent;
		grandParent->leftNode = saveRight;
		grandParent->parentNode = parent;
		// 변경한 subtree 노드들의 색을 알맞게 변경.
		setSubtreeNodeColor(parent);
		// 변경한 subtree가 root일 때 root로 설정.
		if (isRoot(parent)) setRoot(parent);
	}

	void GLR(Node* grandParent, Node* parent, Node* child) {
		Node* saveLeft = child->leftNode;
		Node* saveRight = child->rightNode;
		// 기존 tree와 변경하는 subtreed와 연결.
		if (grandParent->parentNode != NULL) {
			if (grandParent->parentNode->leftNode == grandParent) grandParent->parentNode->leftNode = child;
			else grandParent->parentNode->rightNode = child;
		}
		// child가 변경하는 subtree의 root
		child->leftNode = parent;
		child->rightNode = grandParent;
		child->parentNode = grandParent->parentNode;
		// parent의 자식 설정.
		saveLeft->parentNode = parent;
		parent->rightNode = saveLeft;
		parent->parentNode = child;
		// grandparent의 자식 설정.
		saveRight->parentNode = grandParent;
		grandParent->leftNode = saveRight;
		grandParent->parentNode = child;
		// 변경한 subtree 노드들의 색을 알맞게 변경.
		setSubtreeNodeColor(child);
		// 변경한 subtree가 root일 때 root로 설정.
		if (isRoot(child)) setRoot(child);
	}
	void leftRotation(Node* grandParent, Node* parent, Node* child) {
		if (parent->rightNode == child) 
			// Rotation for the following format.
			// grandParent 
			//		＼
			//		parent
			//			＼
			//			child
			GRR(grandParent, parent, child);
		else 
			// Rotation for the following format.
			// grandParent 
			//		＼
			//		parent
			//		 /
			//	  child
			GRL(grandParent, parent, child);
	}
	void rightRotation(Node* grandParent, Node* parent, Node* child) {
		if (parent->leftNode == child) 
			// Rotation for the following format.
			//		grandParent 
			//			/
			//		parent
			//		 /
			//	  child
			GLL(grandParent, parent, child);
		else 
			// Rotation for the following format.
			//		grandParent 
			//			/
			//		parent
			//			＼
			//			child
			GLR(grandParent, parent, child);
	}
	void recoloring(Node* grandParent, Node* parent, Node* sibling) {
		if (!isRoot(grandParent)) grandParent->color = Color::RED;
		parent->color = Color::BLACK;
		sibling->color = Color::BLACK;
	}
	void restructuring(Node* grandParent, Node* parent, Node* child) {
		if (grandParent->leftNode == parent) 
			// Rotation for the following format.
			//		grandParent 
			//			/
			//		parent
			rightRotation(grandParent, parent, child);
		else 
			// Rotation for the following format.
			// grandParent 
			//		＼
			//		parent
			leftRotation(grandParent, parent, child);
	}

	// 해당 노드를 루트로 설정.
	void setRoot(Node* node) {
		root = node;
		setRootColor();
	}
	// 루트노드의 색을 BLACK으로 설정.
	void setRootColor() {
		root->color = Color::BLACK;
	}
	// restructuring 한 subtree 노드의 색을 변경.
	void setSubtreeNodeColor(Node* subtree) {
		subtree->color = Color::BLACK;
		subtree->leftNode->color = Color::RED;
		subtree->rightNode->color = Color::RED;
	}
	// 중위순위를 수행하면서 범위에 해당하는 app들의 가격을 할인.
	void discountApp(Node* curNode, int startId, int endId, int p) {
		if (curNode->app != NULL) {
			discountApp(curNode->leftNode, startId, endId, p);
			if (curNode->app->id >= startId && curNode->app->id <= endId)
				curNode->app->price = ((curNode->app->price) * (100 - p)) / 100;
			discountApp(curNode->rightNode, startId, endId, p);
		}
	}
	// 해당 노드의 깊이를 리턴.
	int getNodeDepth(Node* node) {
		int depth = 0;
		// 해당 노드부터 위로 올라갈때마다 +1.
		while (node != NULL && node->parentNode != NULL) {
			depth++;
			node = node->parentNode;
		}
		return depth;
	}
	// 해당 노드가 루트인지 판별.
	bool isRoot(Node* node) {
		if (getNodeDepth(node) == 0) return true;
		else return false;
	}
	// 부모와 자식 노드의 색이 모두 RED인지 판별.
	bool isDoubleRed(Node* parentNode, Node* newNode) {
		return (parentNode->color == Color::RED && newNode->color == Color::RED);
	}
	// sibling 노드의 색이 RED인지 판별.
	bool isSiblingRed(Node* siblingNode) {
		return (siblingNode->color == Color::RED);
	}
	// 부모의 형제 노드를 리턴.
	Node* getSibling(Node* parentNode) {
		Node* sibling = NULL;
		// grandparent의 왼쪽 자식이 부모노드일 경우. 형제는 오른쪽 자식.
		if (parentNode->parentNode->leftNode == parentNode) {
			sibling = parentNode->parentNode->rightNode;
			sibling->parentNode = parentNode->parentNode;
		}
		// grandparent의 오른쪽 자식이 부모노드일 경우. 형제는 왼쪽 자식.
		else if (parentNode->parentNode->rightNode == parentNode) {
			sibling = parentNode->parentNode->leftNode;
			sibling->parentNode = parentNode->parentNode;
		}
		return sibling;
	}
	// 해당 id와 동일한 id를 가진 노드를 리턴.
	Node* getNodeUsing(int id) {
		Node* curNode = root;
		Node* getNode = NULL;
		while (curNode->app != NULL) {
			getNode = curNode;
			if (curNode->app->id == id) return getNode;
			else if (curNode->app->id > id)
				curNode = curNode->leftNode;
			else curNode = curNode->rightNode;
		}
		getNode = NULL;
		return getNode;
	}
public:
	RedblackTree() {
		this->root = NULL;
	}

	// App의 내용을 가진 node를 redblacktree에 삽입.
	void insertAppInNode(App* app) {
		Node* newNode = new Node(app);
		Node* saveNewNode = newNode;
		bool isDuplicate = false;
		if (root == NULL) {
			root = newNode;
			setRootColor();
		}
		else {
			Node* curNode = root;
			// newNode를 집어넣을 parentNode
			Node* toParentNode = curNode;
			// newNode를 집어넣을 parentNode를 찾는다.
			// Except NIL 
			while (curNode->app != NULL) {
				toParentNode = curNode;
				if (curNode->app->id == newNode->app->id) {
					cout << "duplicated" << "\n";
					isDuplicate = true;
					break;
				}
				else if (newNode->app->id < curNode->app->id)
					curNode = curNode->leftNode;
				else {
					curNode = curNode->rightNode;
				}
			}
			// save new id smaller than parent Id 
			if (toParentNode->app->id > newNode->app->id) {
				toParentNode->leftNode = newNode;
				newNode->parentNode = toParentNode;
			}
			// save new id larger than parent id
			else {
				toParentNode->rightNode = newNode;
				newNode->parentNode = toParentNode;
			}
			// check double red
			while (isDoubleRed(toParentNode, newNode) && !isDuplicate) {
				// get sibling node
				Node* siblingNode = getSibling(toParentNode);
				if (isSiblingRed(siblingNode)) recoloring(toParentNode->parentNode, toParentNode, siblingNode);
				else restructuring(toParentNode->parentNode, toParentNode, newNode);
				// double red 처리 후에도 double red가 발생했는지 알기 위해 비교 노드를 바꿔준다.
				if (getNodeDepth(toParentNode->parentNode) >= 2) {
					// newNode = grandParentNode
					newNode = getNodeUsing(toParentNode->parentNode->app->id);
					// toParentNode = grandParentNode parent
					toParentNode = getNodeUsing(toParentNode->parentNode->parentNode->app->id);
				}
			}
		}
		cout << getNodeDepth(saveNewNode) << "\n";
	}
	// 해당 id를 가진 노드의 깊의와 App 정보를 출력.
	void printDepthAndAppInformationUsing(int id) {
		Node* node = getNodeUsing(id);
		if (node == NULL) cout << "NULL\n";
		else if (node->app != NULL)
			cout << getNodeDepth(node) << " " << node->app->name << " " << node->app->size << " " << node->app->price << "\n";
	}
	// 해당 id를 가진 노드의 App 정보를 변경.
	void updateAppInformation(App* app) {
		Node* node = getNodeUsing(app->id);
		if (node == NULL) cout << "NULL\n";
		else if (node->app != NULL) {
			node->app->name = app->name;
			node->app->size = app->size;
			node->app->price = app->price;
			cout << getNodeDepth(node) << "\n";
		}
	}
	// 범위 안에 있는 App의 
	void discountAppBetweenByPercent(int startId, int endId, int p) {
		if (root != NULL)
			discountApp(root, startId, endId, p);
	}
};
int main() {
	int tc; cin >> tc;
	RedblackTree rbt;
	while (tc--) {
		string cmd; cin >> cmd;
		// 애플리케이션 등록
		if (cmd == "I") {
			int id, size, price; string name;
			cin >> id >> name >> size >> price;
			rbt.insertAppInNode(new App(id, name, size, price));
		}
		// 애플리케이션 검색
		else if (cmd == "F") {
			int id; cin >> id;
			rbt.printDepthAndAppInformationUsing(id);
		}
		// 애플리케이션 업데이트
		else if (cmd == "R") {
			int id, size, price; string name;
			cin >> id >> name >> size >> price;
			rbt.updateAppInformation(new App(id, name, size, price));
		}
		// 애플리케이션 할인
		else if (cmd == "D") {
			int x, y, P; cin >> x >> y >> P;
			rbt.discountAppBetweenByPercent(x, y, P);
		}
	}
}
